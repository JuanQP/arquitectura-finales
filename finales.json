{
    "finales": [
        {
            "nombre": "Final 01/12/2016",
            "preguntas": [
                {
                    "esSeparador": true,
                    "texto": "Teórico"
                },
                {
                    "pregunta": "¿Desde qué lugar se extraen los valores que permiten la restauración de los registros de CPU para una tarea entrante?",
                    "respuesta": "Estructura de Datos de Pila<br>Pila<br>Stack"
                },
                {
                    "pregunta": "Nombre dos registros de CPU que se utilicen en el campo desplazamiento de una dirección virtual.",
                    "respuesta": "Las instrucciones <code>EIP</code> y <code>ESP</code>",
                    "explicacion": "Recordemos que son los <strong>punteros</strong> (esa palabra debería darnos una pista de que sirven para hacer desplazamientos) de instrución, y el puntero de stack."
                },
                {
                    "pregunta": "¿Cuál es la finalidad de los registros 'SI' y 'DI' en modo real?",
                    "respuesta": "Se utilizan en direccionamiento indexado.<br>Sirven para trabajar con cadenas de caracteres."
                },
                {
                    "pregunta": "¿A qué hace referencia el concepto MODO directo por registro o de registro?",
                    "respuesta": "Es el modo de direccionamiento en el cual el operando (<em>el valor que se pasa a una instrucción</em>) se aloja en un registro de la CPU.",
                    "explicacion": "Cuando usamos por ejemplo <code>MOV AX, BX</code>, estamos utilizando datos de <code>BX</code> que se encuentran en un registro, no estamos accediendo a memoria."
                },
                {
                    "pregunta": "Si el campo EDATA de una instrucción de 32 bits aloja un dato (modo inmediato) ¿Cuál es su valor máximo entero? Escríbalo en hexadecimal o en potencias de 2.",
                    "respuesta": "2^(Cantidad de bits - 1) entonces 2^(32) - 1",
                    "explicacion": "Nos está diciendo que el campo tiene 32 bits y que tiene el valor en la instrucción misma (modo inmediato). Entonces simplemente tenemos que responder cuál es el valor máximo que se puede lograr con 32 bits o sea <code>FF FF FF FF</code>."
                },
                {
                    "pregunta": "¿Qué es un hercio o Hz?",
                    "respuesta": "Es una medida de frecuencia, representa los <strong>ciclos por segundo</strong> de un CPU."
                },
                {
                    "pregunta": "Cómo se denomina la señal que indica la solicitud de atención por parte de un dispositivo externo?",
                    "respuesta": "La señal <code>INTR</code>.",
                    "explicacion": "No confundir con <code>INTO</code>, o <code>INT n</code> que son instrucciones de interrupción que puede activar un programador."
                },
                {
                    "pregunta": "¿Cómo clasificaría una interrupción producida por una división por cero?",
                    "respuesta": "Excepción."
                },
                {
                    "pregunta": "Sabiendo que la dirección física de la última posición de una memoria es <code>FF FF FF FF</code><br>¿Cuál es el valor de <code>m</code> de esa memoria si es direccionable al octeto? (O dicho de otra manera de m X 8)",
                    "respuesta": "m = 4G de posiciones"
                },
                {
                    "pregunta": "Indique el correspondiente rango de direcciones.",
                    "respuesta": "[0, 2^{32}-1]",
                    "explicacion": "Desde qué número a qué número pueden ser esas posiciones."
                },
                {
                    "esSeparador": true,
                    "texto": "Práctica"
                },
                {
                    "pregunta": "Para la línea de código presentada a continuación y considerando un contexto en modo real (o modo 16 bits)<br><code>3BB0:0103 MOV AX, [35B0]</code><br>Si el valor del DS es <code>AB55</code>, ¿Cuál es la dirección física del operando involucrado en ésta instrucción?",
                    "respuesta": "AEB00",
                    "explicacion": "Recordar que la expresión <code>[35B0]</code> significa 'el contenido de la posición...', y como acá dice que la posición de <code>DS</code> es <code>AB55</code>, hay que aplicar la formulita para obtener la dirección física (la dirección lógica sería <code>AB55:35B0</code>, y la física es la que resulta de aplicar <code>(AB55 x 10) + 35B0</code>, con lo cual al multiplicar tendríamos <code>AB550 + 35B0</code> y finalmente <code>AEB00</code>)."
                },
                {
                    "pregunta": "Si el valor del <code>SS</code> es <code>3700</code> y el valor del <code>SP</code> es <code>FFFE</code>, ¿Cuál será la dirección segmentada asociada al byte vacío de la pila luego de una instrucción <code>PUSH</code>?",
                    "respuesta": "<code>3700:FFFC</code>",
                    "explicacion": "Previo al <code>PUSH</code> tenemos que la dirección segmentada a la que apunta la pila es <code>SS:SP</code> (Segmento de Pila : Puntero de Pila), o sea <code>3700:FFFE</code>. Hay que recordar que cuando hacemos <code>PUSH</code> el puntero <strong>decrementa</strong> (si, una locura), y cuando hacemos <code>POP</code> el puntero <strong>incrementa</strong>. Estas variaciones las hace de a 2 bytes. Así que el puntero que ahora vale <code>FFFE</code>, luego de un <code>PUSH</code> decrementaría 2 bytes hasta valer <code>FFFC</code>. Entonces, ya podemos mostrar la dirección segmentada <code>SS:SP</code> que sería <code>3700:FFFC</code>."
                },
                {
                    "pregunta": "Si la instrucción siguiente a la descripta se aloja en la dirección física <code>3BC07</code>, ¿Cuál es el tamaño de la instrucción y cuántos bytes le corresponden al código de operación?",
                    "respuesta": "4 bytes de instrucción, en los que 2bytes de código de operación y 2 bytes del campo de referencia al dato <code>35B0</code>",
                    "explicacion": "Primero deberíamos ver cuál es la dirección física de dicha instrucción, la cual sabiendo que tenemos <code>3BB0:0103</code>, obtenemos que es <code>3BB0 x 10 + 0103 = 3BC03</code>. Como la pregunta dice que la próxima instrucción está en <code>3BC07</code>, y esta instrucción arrancaba en <code>3BC03</code>, significa que hay <code>4 bytes</code> de diferencia (o sea que esta instrucción ocupa 4 bytes en memoria). Lo siguiente no es tan obvio, pero hay que razonarlo: como estamos pasando un número a esta instrucción, el número <code>35B0</code>, que ocupa 2 bytes, nos quedan solo 2 bytes que tienen que ser lo que ocupa el código de instrucción."
                },
                {
                    "pregunta": "Un proceso que se ejecuta en un sistema con memoria virtual puramente segmentada tiene un primer segmento de código de 4096 bytes. ¿Cuál es el valor del campo límite del correspondiente descriptor de segmento?",
                    "respuesta": "01000(16) = 0000 0001 0000 0000 0000(2)",
                    "explicacion": "Recordemos que el campo límite son 20 bits que definen qué tan largo es un segmento. Si este segmento tiene 4096 bytes, entonces el campo límite de este segmento debería tener el valor 4096 en binario."
                },
                {
                    "pregunta": "¿Qué valor tiene el bit <code>P</code> de presencia cuando la CPU está ejecutando la tercera instrucción?",
                    "respuesta": "P=1",
                    "explicacion": "El bit de presencia es un flag que está en 1 cuando un segmento está cargado en memoria. El hecho de que se esté <em>ejecutando una instrucción</em> de dicho segmento, implica que tiene que estar cargado en memoria. El hecho de haber puesto 'tercera instrucción', es simplemente para despistar."
                },
                {
                    "pregunta": "Si el valor del campo base correspondiente al mismo descriptor expresado en hexadecimal es <code>00 00 10 00</code>, ¿Cuál es la dirección física que correspondería al último byte del segmento?",
                    "respuesta": "00 00 1F FF",
                    "explicacion": "El campo base son 32 bits que definen en qué posición empieza un segmento. Si el segmento empieza en <code>00 00 10 00</code>, y el tamaño dijimos que era <code>0 10 00</code>, entonces <code>00 00 10 00 + 0 10 00 = 00 00 20 00</code>. Este <code>00 00 20 00</code> sería donde empieza el <strong>próximo segmento</strong>, por lo cual, el <strong>último byte del segmento que estamos calculando</strong> sería el byte previo a ése, es decir: <code>00 00 1F FF</code>."
                }
            ]
        },

        {
            "nombre": "Final 06/10/2016",
            "preguntas": [
                {
                    "esSeparador": true,
                    "texto": "Teórico"
                },
                {
                    "pregunta": "¿Cómo se denomina la estructura de datos que se utiliza en determinadas ocasiones, para resguardar el contenido de los registros de CPU?",
                    "respuesta": "Pila o Stack."
                },
                {
                    "pregunta": "¿Cuál es el nombre genérico de la técnica para actualizar la memoria principal desde caché? ¿Cuál es la denominación particular cuando se escribe en MP al mismo tiempo que en caché?",
                    "respuesta": "El nombre de técnica para actualizar la memoria principal desde caché se denomina <strong>Política de Escritura</strong> (puede ser una de varias).<br>La técnica en particular para escribir en MP (memoria principal) al mismo tiempo que en caché es <strong>Escritura Inmediata</strong>"
                },
                {
                    "pregunta": "¿Cuál es la finalidad de los 'registros de segmento' en modo real y en modo protegido?",
                    "respuesta": "En modo real contiene la base de alguna estructura de datos (como por ejemplo CS, SS, ó DS, entre otros). En modo protegido contiene el selector de dichos segmentos."
                },
                {
                    "pregunta": "¿Cómo se denomina el registro que actúa como 'contador de programa' o 'puntero de instrucción'? ¿De cuántos bits puede constar?",
                    "respuesta": "Se llama <strong>Instruction Pointer (IP)</strong> y consta de 16 bits cuando se usa el registro <code>IP</code> o puede tener 32 bits cuando se usa el registro <code>EIP</code>."
                },
                {
                    "pregunta": "¿Dónde se encuentra el operando cuando se utiliza direccionamiento inmediato?",
                    "respuesta": "En la misma instrucción.<br>También es válido decir 'en el campo DATA'."
                },
                {
                    "pregunta": "¿Qué es el Buffer de Traducción Anticipada y qué información se guarda en este dispositivo?",
                    "respuesta": "Es una memoria de capacidad reducida que guarda la dirección lineal y la dirección física de las últimas 32 páginas de código accedidas dentro de un microprocesador."
                },
                {
                    "pregunta": "¿En qué unidad se mide el ciclo completo de una instrucción?",
                    "respuesta": "En ciclos de reloj, en hertz, en hz..."
                },
                {
                    "pregunta": "¿Cómo se denomina la señal de respuesta de la CPU a la solicitud de atención por parte de un dispositivo externo? ¿Qué módulo especial gestiona las señales provenientes del entorno de dispositivos?",
                    "respuesta": "La señal es <code>INTA</code> (Interruption Acknowledge). Las gestiona el módulo APIC."
                },
                {
                    "pregunta": "¿Cómo se denomina el parámetro que indica la cantidad de bits que se transmiten por unidad de tiempo a través de un bus y en qué unidades se mide?",
                    "respuesta": "Velocidad de transferencia. Se mide en Megabit/s o Gigabit/s"
                },
                {
                    "esSeparador": true,
                    "texto": "Práctica"
                },
                {
                    "pregunta": "Sabiendo que una CPU genera una dirección de 34 bits que permiten acceder a la memoria principal.<br>¿Cuál es el tamaño potencial de la memoria principal?",
                    "respuesta": "16GB",
                    "explicacion": "Podemos razonarlo de esta forma: Si las viejas máquinas de 32 bits permitían direccionar 4GB, entonces con un bit más (33 bits) podrían hacer 8GB, y entonces con otro bit más (34 bits) podrían hacer 16GB."
                },
                {
                    "pregunta": "¿Cuántos bits son significativos para direccionar una memoria DRAM de 8 Gigabytes?",
                    "respuesta": "33 bits.",
                    "explicación": "Tener en cuenta la explicación de la respuesta anterior."
                },
                {
                    "pregunta": "Si el total de los 8 Giga están distribuidos en cuatro placas de 8 chips cada una ¿Cómo esta armada la matriz de mX8 en cada chip y cual es la capacidad de cada uno?",
                    "respuesta": "La matriz sería de 256MX8 y tendría una capacidad de 256MB cada una.",
                    "explicacion": "La capacidad es una cuenta matemática (8GB dividida en 4 placas da 2GB, y dice que cada placa tiene 8chips, entonce 2GB / 8 chips = 256MB).<br>La matriz de MX8 es la cantidad de <em>bloquecitos de 1 byte</em> que pueden haber."
                },
                {
                    "pregunta": "Un proceso que se ejecuta en un sistema con memoria virtual puramente segmentada tiene un primer segmento de código de 4096 bytes. ¿Cuánto vale el campo el campo P de presencia cuando el programa está ejecutando la tercera instrucción?",
                    "respuesta": "El flag estaría <code>P=1</code>",
                    "explicacion": "El <strong>bit de presencia</strong> indica que un segmento está cargado en memoria. Como el enunciado dice que se está ejecutando una instrucción (no importa si es la tercera), significa que debería estar cargado en memoria."
                },
                {
                    "pregunta": "¿Qué valor de la entidad “selector” de la dirección virtual permite acceder al segmento?",
                    "respuesta": "El Indice de Tabla (o TI), bit 2 del selector que esté en 0, indicando que la Tabla de Descriptores es Local."
                },
                {
                    "pregunta": "¿Qué valor tiene el bit G de Granularidad?",
                    "respuesta": "El flag estaría en <code>G=0</code>",
                    "explicacion": "El <strong>flag de granularidad</strong> indica si el tamaño de los segmentos están en bytes ó en megabytes. Como el enunciado mismo decía que el segmento era de 4096bytes, entonces el flag G debería estar en 0."
                },
                {
                    "pregunta": "Si la base alojada en su descriptor y expresada en hexadecimal es <code>32 42 70 00</code>. ¿Cuál es la dirección física que correspondería al último byte del segmento?",
                    "respuesta": "<code>32 42 7F FF</code>",
                    "explicacion": "Si el tamaño del segmento es de 4096 bytes (lo decía el enunciado), significa que el campo que indica el tamaño de segmento (20 bits) debe ser <code>01000</code> (en hexadecimal). La técnica que podemos usar para saber cuál es el último byte, es sumar el tamaño de segmento, con la base (<code>32 42 70 00 + 0 10 00 = 32 42 80 00</code>), lo cual nos da <strong>el primer byte del segmento próximo</strong>. Si restamos 1 a ese resultado, nos daría el último byte del segmento que estábamos calculando: <code>32 42 7F FF</code>."
                },
                {
                    "pregunta": "Para la línea de código presentada a continuación<br><code>AB55:0103 MOV AX, [AAAA]</code><br>Si la instrucción siguiente a la descripta se aloja en la dirección física <code>AB656</code>, ¿Cuál es el tamaño de la instrucción y cuántos bytes le corresponden al código de operación?",
                    "respuesta": "3 bytes: 2 para el operando <code>AAAA</code> y el restante para el código de operación.",
                    "explicacion": "Calculamos la dirección física primero de lo que tenemos <code>AB55 x 10 + 0103 = AB653</code>. Si la próxima instrucción va a estar en <code>AB656</code>, significa que hay 3 bytes de diferencia. Como vemos que en la instrucción se están usando 2 bytes para representar el dato <code>AAAA</code>, sólo nos queda concluir que el byte restante es el <strong>código de operación</strong>."
                }
            ]
        }
    ]
}
